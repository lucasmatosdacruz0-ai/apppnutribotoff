
import { GoogleGenAI, Type } from "@google/genai";

// --- Gemini API Setup ---
let aiInstance;
const getAi = () => {
    if (aiInstance) return aiInstance;
    const apiKey = process.env.API_KEY;
    if (!apiKey) {
        throw new Error("A chave da API do Gemini (API_KEY) n√£o foi encontrada nas vari√°veis de ambiente do Netlify.");
    }
    aiInstance = new GoogleGenAI({ apiKey });
    return aiInstance;
};

// Centralized error handler for Gemini API calls on the server-side
const handleGeminiError = (error, context) => {
    console.error(`Error during Gemini API call in '${context}':`, error);
    let errorMessage = `Ocorreu um erro em '${context}'. Tente novamente.`;

    if (error instanceof Error) {
        if (error.message.includes('API key not valid') || error.message.includes('API_KEY_INVALID')) {
            errorMessage = "Erro de Autentica√ß√£o: A chave da API √© inv√°lida. Verifique a vari√°vel de ambiente (API_KEY) no seu painel do Netlify e fa√ßa o deploy novamente.";
        } else if (error.message.includes('fetch failed') || error.message.toLowerCase().includes('network')) {
            errorMessage = "Erro de Rede: O servidor n√£o conseguiu conectar ao servi√ßo de IA.";
        } else if (error.message.includes('429')) {
             errorMessage = "Voc√™ atingiu o limite de requisi√ß√µes para a API. Por favor, verifique seu plano e uso no Google AI Studio e tente novamente mais tarde.";
        } else if (error.message.includes('SAFETY')) {
            errorMessage = "A sua solicita√ß√£o ou a resposta da IA foi bloqueada por quest√µes de seguran√ßa. Tente reformular seu pedido com outras palavras.";
        } else if (error.message.includes('Invalid JSON response')) {
             errorMessage = "A IA retornou uma resposta em formato inv√°lido. Tente novamente, talvez com um pedido mais simples.";
        } else {
            errorMessage = `Ocorreu um erro inesperado ao comunicar com a IA. Por favor, tente novamente. Detalhe: ${error.message}`;
        }
    }
    
    return new Error(errorMessage);
};

// --- Models & Schemas ---
const FAST_MODEL = 'gemini-2.5-flash';
const DATA_GENERATION_MODEL = 'gemini-2.5-flash';
const IMAGE_GENERATION_MODEL = 'imagen-4.0-generate-001';

const macroDataSchema = {};
const activityLogSchema = {};
const foodItemSchema = {};
const mealSchema = {};
const dailyPlanSchema = {};
const weeklyPlanSchema = {};
const recipeSchema = {};

Object.assign(macroDataSchema, { type: Type.OBJECT, properties: { calories: { type: Type.NUMBER }, carbs: { type: Type.NUMBER }, protein: { type: Type.NUMBER }, fat: { type: Type.NUMBER } }, required: ["calories", "carbs", "protein", "fat"] });
Object.assign(activityLogSchema, { type: Type.OBJECT, properties: { type: { type: Type.STRING }, duration: { type: Type.NUMBER }, caloriesBurned: { type: Type.NUMBER } }, required: ["type", "duration", "caloriesBurned"] });
Object.assign(foodItemSchema, { type: Type.OBJECT, properties: { name: { type: Type.STRING }, portion: { type: Type.STRING }, calories: { type: Type.NUMBER }, carbs: { type: Type.NUMBER }, protein: { type: Type.NUMBER }, fat: { type: Type.NUMBER } }, required: ["name", "portion", "calories", "carbs", "protein", "fat"] });
Object.assign(mealSchema, { type: Type.OBJECT, properties: { id: { type: Type.STRING }, name: { type: Type.STRING }, time: { type: Type.STRING }, totalCalories: { type: Type.NUMBER }, totalMacros: macroDataSchema, items: { type: Type.ARRAY, items: foodItemSchema } }, required: ["id", "name", "time", "totalCalories", "totalMacros", "items"] });
Object.assign(dailyPlanSchema, { type: Type.OBJECT, properties: { date: { type: Type.STRING }, dayOfWeek: { type: Type.STRING }, totalCalories: { type: Type.NUMBER }, totalMacros: macroDataSchema, waterGoal: { type: Type.NUMBER }, meals: { type: Type.ARRAY, items: mealSchema } }, required: ["date", "dayOfWeek", "totalCalories", "totalMacros", "waterGoal", "meals"] });
Object.assign(weeklyPlanSchema, { type: Type.OBJECT, properties: { weekly_plan: { type: Type.ARRAY, items: dailyPlanSchema } }, required: ['weekly_plan'] });
Object.assign(recipeSchema, { type: Type.OBJECT, properties: { recipes: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { id: { type: Type.STRING }, title: { type: Type.STRING }, description: { type: Type.STRING }, prepTime: { type: Type.STRING }, difficulty: { type: Type.STRING, enum: ['F√°cil', 'M√©dio', 'Dif√≠cil'] }, servings: { type: Type.STRING }, ingredients: { type: Type.ARRAY, items: { type: Type.STRING } }, instructions: { type: Type.ARRAY, items: { type: Type.STRING } }, nutritionalInfo: { type: Type.OBJECT, properties: { calories: { type: Type.STRING }, protein: { type: Type.STRING }, carbs: { type: Type.STRING }, fat: { type: Type.STRING } }, required: ["calories", "protein", "carbs", "fat"] }, imagePrompt: { type: Type.STRING } }, required: ["id", "title", "description", "prepTime", "difficulty", "servings", "ingredients", "instructions", "nutritionalInfo", "imagePrompt"] } } }, required: ["recipes"] });

const getUserContextForPrompt = (userData) => {
    const { macros, dietaryPreferences, adminSettings, weight, weightGoal, age, gender, height, activityLevel } = userData;
    const objective = weight > weightGoal ? 'perda de peso' : weight < weightGoal ? 'ganho de massa' : 'manuten√ß√£o de peso';
    const userContext = {
        objetivo,
        metas_diarias: { calorias: macros.calories.goal, proteinas: macros.protein.goal, carboidratos: macros.carbs.goal, gorduras: macros.fat.goal },
        preferencias: { dietas: dietaryPreferences.diets.join(', ') || 'Nenhuma', restricoes: dietaryPreferences.restrictions.join(', ') || 'Nenhuma' },
        dados_pessoais: { idade: age, genero: gender, altura: height, peso: weight, nivel_atividade: activityLevel },
    };
    const adminInstructionPrompt = adminSettings?.permanentPrompt ? `\n- Regra Permanente do Nutricionista (OBRIGAT√ìRIO SEGUIR): ${adminSettings.permanentPrompt}` : '';
    return { userContextJSON: JSON.stringify(userContext), adminInstructionPrompt };
};

// --- API Logic Functions ---
const apiFunctions = {
    chatStream: async ({ message, history }) => {
        const ai = getAi();
        const chat = ai.chats.create({
            model: FAST_MODEL,
            history: history,
            config: {
                systemInstruction: `Voc√™ √© o NutriBot, um assistente nutricionista de IA. Suas respostas devem ser em portugu√™s do Brasil, sempre bem estruturadas, claras e agrad√°veis de ler, mas sem usar muitos tokens. Utilize Markdown para formatar suas respostas da seguinte maneira:

- **T√≠tulos e Se√ß√µes:** Use headings (ex: \`## T√≠tulo\`) para organizar o conte√∫do.
- **Destaques:** Use negrito (\`**texto**\`) para enfatizar informa√ß√µes importantes.
- **Listas:** Use listas com marcadores (\`- Item 1\`) para itens como ingredientes ou dicas.
- **Tabelas:** SEMPRE que fornecer uma dieta, lista de compras ou dados comparativos, apresente as informa√ß√µes em uma tabela Markdown para m√°xima clareza.
- **Emojis:** Use emojis de forma moderada e apropriada para tornar a conversa amig√°vel (ü•ë, üí™, üíß).
- **Sele√ß√£o de Alimentos:** Ao sugerir alimentos ou criar planos, d√™ prefer√™ncia a ingredientes que s√£o comuns na dieta brasileira e f√°ceis de encontrar em supermercados no Brasil.
- **Macros e Metas:** Ao criar dietas, esforce-se para atingir as metas de calorias e macronutrientes do usu√°rio.
- **Gramatura:** Sempre inclua a por√ß√£o em gramas junto da medida caseira. Exemplo: "1 x√≠cara de arroz (200g)".

Seja conciso, mas completo, focando em fornecer valor pr√°tico ao usu√°rio.`,
            },
        });
        return chat.sendMessageStream({ message });
    },
    parseMealPlanText: async ({ text }) => {
        const ai = getAi();
        const prompt = `Analise o seguinte texto, que cont√©m um plano alimentar, e extraia os dados estruturados. A sa√≠da DEVE ser um √∫nico objeto JSON que corresponda ao schema 'dailyPlanSchema'. Texto para analisar: "${text}"`;
        const response = await ai.models.generateContent({ model: DATA_GENERATION_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: dailyPlanSchema } });
        return JSON.parse(response.text);
    },
    regenerateDailyPlan: async ({ userData, currentPlan, numberOfMeals }) => {
        const ai = getAi();
        const { userContextJSON, adminInstructionPrompt } = getUserContextForPrompt(userData);
        const mealCountPrompt = numberOfMeals ? `A nova dieta deve ter exatamente ${numberOfMeals} refei√ß√µes.` : `A nova dieta deve ter ${currentPlan.meals.length} refei√ß√µes.`;
        const prompt = `
            Tarefa: Gerar uma nova dieta di√°ria para o usu√°rio.
            Sa√≠da: JSON, schema 'dailyPlanSchema'.
            Contexto do Usu√°rio: ${userContextJSON}
            Regras:
            - Criar uma dieta COMPLETAMENTE NOVA e diferente da anterior.
            - A data do plano deve ser a mesma da anterior: ${currentPlan.date}.
            - ${mealCountPrompt}
            - Os nomes das refei√ß√µes devem ser padr√£o (Ex: Caf√© da Manh√£, Almo√ßo).
            - As calorias e macros totais devem se aproximar ao m√°ximo das metas do usu√°rio.
            ${adminInstructionPrompt}`;
        const response = await ai.models.generateContent({ model: DATA_GENERATION_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: dailyPlanSchema } });
        return JSON.parse(response.text);
    },
    adjustDailyPlanForMacro: async ({ userData, currentPlan, macroToFix }) => {
        const ai = getAi();
        const { userContextJSON, adminInstructionPrompt } = getUserContextForPrompt(userData);
        const prompt = `
            Tarefa: Ajustar a dieta di√°ria existente para melhorar a meta do macronutriente '${macroToFix}'.
            Sa√≠da: JSON, schema 'dailyPlanSchema'.
            Contexto do Usu√°rio: ${userContextJSON}
            Dieta Atual: ${JSON.stringify(currentPlan)}
            Regras:
            - Modifique a dieta atual fazendo o m√≠nimo de trocas poss√≠vel para aproximar o total de '${macroToFix}' da meta do usu√°rio.
            - Mantenha as calorias totais o mais pr√≥ximo poss√≠vel da meta.
            - Mantenha a mesma data e n√∫mero de refei√ß√µes.
            ${adminInstructionPrompt}`;
        const response = await ai.models.generateContent({ model: DATA_GENERATION_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: dailyPlanSchema } });
        return JSON.parse(response.text);
    },
    generateWeeklyPlan: async ({ userData, weekStartDate, observation }) => {
        const ai = getAi();
        const { userContextJSON, adminInstructionPrompt } = getUserContextForPrompt(userData);
        const observationPrompt = observation ? `Observa√ß√£o do usu√°rio para esta semana: "${observation}"` : '';
        const prompt = `
            Tarefa: Gerar um plano alimentar para 7 dias.
            Sa√≠da: JSON, schema 'weeklyPlanSchema'.
            Contexto do Usu√°rio: ${userContextJSON}
            Data de In√≠cio da Semana: ${new Date(weekStartDate).toISOString().split('T')[0]}
            ${observationPrompt}
            Regras:
            - Gerar um plano para 7 dias consecutivos, come√ßando na data de in√≠cio.
            - Variedade √© crucial: n√£o repita refei√ß√µes principais em dias seguidos.
            - As calorias e macros de cada dia devem se aproximar das metas do usu√°rio.
            - As datas e dias da semana devem estar corretos para cada um dos 7 dias.
            ${adminInstructionPrompt}`;
        const response = await ai.models.generateContent({ model: DATA_GENERATION_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: weeklyPlanSchema } });
        const parsed = JSON.parse(response.text);
        return (parsed.weekly_plan || []).reduce((acc, day) => {
            acc[day.date] = day;
            return acc;
        }, {});
    },
    regenerateMealFromPrompt: async ({ prompt, meal, userData }) => {
        const ai = getAi();
        const { userContextJSON, adminInstructionPrompt } = getUserContextForPrompt(userData);
        const requestPrompt = `
            Tarefa: Recriar uma refei√ß√£o com base na instru√ß√£o do usu√°rio.
            Sa√≠da: JSON, schema 'mealSchema'.
            Contexto do Usu√°rio: ${userContextJSON}
            Refei√ß√£o Original: ${JSON.stringify(meal)}
            Instru√ß√£o do Usu√°rio: "${prompt}"
            Regras:
            - A nova refei√ß√£o deve seguir a instru√ß√£o e ter calorias e macros similares √† original, a menos que a instru√ß√£o pe√ßa o contr√°rio.
            - Mantenha o mesmo ID e nome da refei√ß√£o original.
            - O hor√°rio ('time') deve ser mantido.
            ${adminInstructionPrompt}`;
        const response = await ai.models.generateContent({ model: DATA_GENERATION_MODEL, contents: requestPrompt, config: { responseMimeType: "application/json", responseSchema: mealSchema } });
        return JSON.parse(response.text);
    },
    analyzeMealFromText: async ({ description }) => {
        const ai = getAi();
        const prompt = `Analise a descri√ß√£o desta refei√ß√£o e estime os macronutrientes. Responda apenas com o JSON. Descri√ß√£o: "${description}"`;
        const response = await ai.models.generateContent({ model: FAST_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: macroDataSchema } });
        return JSON.parse(response.text);
    },
    analyzeMealFromImage: async ({ imageDataUrl }) => {
        const ai = getAi();
        const base64Data = imageDataUrl.split(',')[1];
        const imagePart = { inlineData: { mimeType: 'image/jpeg', data: base64Data } };
        const textPart = { text: "Analise a imagem desta refei√ß√£o e estime os macronutrientes. Se n√£o conseguir identificar, retorne zero para todos. Responda apenas com o JSON." };
        const response = await ai.models.generateContent({ model: FAST_MODEL, contents: { parts: [imagePart, textPart] }, config: { responseMimeType: "application/json", responseSchema: macroDataSchema } });
        return JSON.parse(response.text);
    },
    analyzeProgress: async ({ userData }) => {
        const ai = getAi();
        const prompt = `Com base nos dados do usu√°rio, fa√ßa um resumo motivacional sobre sua evolu√ß√£o. Destaque pontos fortes, sugira √°reas para melhorar e d√™ dicas para continuar progredindo. Use um tom amig√°vel e encorajador. Dados: ${JSON.stringify(userData)}`;
        const response = await ai.models.generateContent({ model: FAST_MODEL, contents: prompt });
        return response.text;
    },
    generateShoppingList: async ({ weekPlan }) => {
        const ai = getAi();
        const prompt = `Crie uma lista de compras detalhada e organizada por categorias (ex: Frutas, Legumes, Carnes, Latic√≠nios) para o seguinte plano alimentar semanal. Some as quantidades de ingredientes id√™nticos. Plano: ${JSON.stringify(weekPlan)}`;
        const response = await ai.models.generateContent({ model: FAST_MODEL, contents: prompt });
        return response.text;
    },
    getFoodInfo: async ({ question, mealContext }) => {
        const ai = getAi();
        const contextPrompt = mealContext ? `O usu√°rio est√° vendo esta refei√ß√£o: ${JSON.stringify(mealContext)}.` : '';
        const prompt = `Responda √† seguinte d√∫vida sobre alimentos de forma clara e concisa. ${contextPrompt} Pergunta: "${question}"`;
        const response = await ai.models.generateContent({ model: FAST_MODEL, contents: prompt });
        return response.text;
    },
    getFoodSubstitution: async ({ itemToSwap, mealContext, userData }) => {
        const ai = getAi();
        const { userContextJSON, adminInstructionPrompt } = getUserContextForPrompt(userData);
        const prompt = `
            Tarefa: Encontrar um substituto saud√°vel para um alimento.
            Sa√≠da: JSON, schema 'foodItemSchema'.
            Contexto do Usu√°rio: ${userContextJSON}
            Contexto da Refei√ß√£o: ${JSON.stringify(mealContext)}
            Alimento para Trocar: ${JSON.stringify(itemToSwap)}
            Regras:
            - Encontre um substituto com calorias e macronutrientes o mais pr√≥ximo poss√≠vel do original.
            - O substituto deve fazer sentido no contexto da refei√ß√£o.
            - Respeite as prefer√™ncias do usu√°rio.
            ${adminInstructionPrompt}`;
        const response = await ai.models.generateContent({ model: DATA_GENERATION_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: foodItemSchema } });
        return JSON.parse(response.text);
    },
    findRecipes: async ({ query, userData, numRecipes }) => {
        const ai = getAi();
        const { userContextJSON, adminInstructionPrompt } = getUserContextForPrompt(userData);
        const prompt = `
            Tarefa: Encontrar ${numRecipes} receita(s) criativa(s).
            Sa√≠da: JSON, schema 'recipeSchema'.
            Busca do Usu√°rio: "${query}"
            Contexto do Perfil: ${userContextJSON}
            Regras:
            - Relev√¢ncia m√°xima com a busca do usu√°rio.
            - Adaptar receitas para serem saud√°veis e respeitar o perfil.
            - Priorizar ingredientes comuns no Brasil.
            - Para cada receita, criar um 'imagePrompt' detalhado e otimizado para IA de imagem (estilo fotografia de comida realista, apetitosa, alta qualidade).
            ${adminInstructionPrompt}`;
        
        const response = await ai.models.generateContent({ model: DATA_GENERATION_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: recipeSchema, thinkingConfig: { thinkingBudget: 0 } } });
        const parsed = JSON.parse(response.text);
        return parsed.recipes || [];
    },
    generateImageFromPrompt: async ({ prompt }) => {
        const ai = getAi();
        const response = await ai.models.generateImages({
            model: IMAGE_GENERATION_MODEL,
            prompt: `Crie uma imagem realista e de alta qualidade com base na seguinte descri√ß√£o: ${prompt}. Estilo de fotografia de alimentos, ilumina√ß√£o profissional, fundo desfocado.`,
            config: { numberOfImages: 1, outputMimeType: 'image/jpeg', aspectRatio: '1:1' },
        });
        if (response.generatedImages?.[0]?.image?.imageBytes) {
            return `data:image/jpeg;base64,${response.generatedImages[0].image.imageBytes}`;
        }
        throw new Error("A IA n√£o retornou nenhuma imagem.");
    },
    analyzeActivityFromText: async ({ description }) => {
        const ai = getAi();
        const prompt = `Analise a descri√ß√£o desta atividade f√≠sica e estime o tipo, dura√ß√£o em minutos e calorias queimadas. Responda apenas com o JSON. Descri√ß√£o: "${description}"`;
        const response = await ai.models.generateContent({ model: FAST_MODEL, contents: prompt, config: { responseMimeType: "application/json", responseSchema: activityLogSchema } });
        return JSON.parse(response.text);
    },
};

// --- Netlify Function Handler ---
export const handler = async (event) => {
    if (event.httpMethod !== 'POST') {
        return { statusCode: 405, body: JSON.stringify({ error: 'Method Not Allowed' }) };
    }

    try {
        const { action, payload } = JSON.parse(event.body);

        if (action === 'chatStream') {
            const streamResult = await apiFunctions.chatStream(payload);
            
            // This is how you handle streaming responses in Netlify functions
            const stream = new ReadableStream({
                async start(controller) {
                    try {
                        for await (const chunk of streamResult) {
                            controller.enqueue(`data: ${JSON.stringify(chunk)}\n\n`);
                        }
                    } catch (e) {
                        console.error("Stream error in handler:", e);
                        const processedError = handleGeminiError(e, action);
                        controller.enqueue(`data: ${JSON.stringify({ error: processedError.message })}\n\n`);
                    } finally {
                        controller.close();
                    }
                }
            });
            
            return {
                statusCode: 200,
                headers: { 
                    'Content-Type': 'text/event-stream',
                    'Cache-Control': 'no-cache',
                    'Connection': 'keep-alive',
                },
                body: stream,
            };

        } else if (apiFunctions[action]) {
            const data = await apiFunctions[action](payload);
            return {
                statusCode: 200,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data }),
            };
        } else {
            return { statusCode: 400, body: JSON.stringify({ error: 'Invalid action' }) };
        }

    } catch (error) {
        const { action } = JSON.parse(event.body || '{}');
        const processedError = handleGeminiError(error, action || 'handler');
        console.error("Handler error:", processedError);
        return {
            statusCode: 500,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ error: processedError.message }),
        };
    }
};
